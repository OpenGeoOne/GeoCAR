# -*- coding: utf-8 -*-

"""
/***************************************************************************
 GeoCAR
                                 A QGIS plugin
 Georreferenciamento de Imóveis Rurais
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-09-30
        copyright            : (C) 2024 by Prof Cazaroli e Leandro França
        email                : contato@geoone.com.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Prof Cazaroli e Leandro França'
__date__ = '2024-09-30'
__copyright__ = '(C) 2024 by Prof Cazaroli e Leandro França'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'
#xxxx
from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.core import (
            QgsProcessingAlgorithm,
            QgsProject,
            QgsFeatureRequest,
            QgsVectorLayer,
            QgsField,
            QgsCoordinateTransform,
            QgsCoordinateReferenceSystem,
            QgsProcessingParameterExtent,
            QgsProcessingException,
            QgsProcessingParameterEnum,
            QgsProcessingLayerPostProcessorInterface)
import requests
import zipfile
import os
from qgis.PyQt.QtGui import QIcon
#from GeoINCRA.images.Imgs import *

class obtemCAR(QgsProcessingAlgorithm):
    EXTENT = 'EXTENT'
    WFS = 'WFS'

    mapping ={
               0: 'Áreas dos Imóveis com CAR',
               1: 'Áreas com altitude maior que 1.800 metros',
               2: 'Áreas com declividade superior a 45 graus',
               # 3: 'RBMC (IBGE)',
            }
    nome = {
        0: 'Area_CAR',
        1: 'Area_Maior_1800m',
        2: 'Area_Superior_45graus',
    }
      
    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterExtent(
                self.EXTENT,
                self.tr('Retângulo de Extensão')
            )
        )

        self.addParameter(
            QgsProcessingParameterEnum(
                self.WFS,
                self.tr('Camada de interesse'),
                options = list(self.mapping.values()),
                defaultValue= 0
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        # obtendo os parâmetros de entrada
        extensao = self.parameterAsExtent(parameters, self.EXTENT, context)
        if not extensao:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.EXTENT))

        option = self.parameterAsEnum(parameters, self.WFS, context)
        layer = self.nome.get(option)
        
        # =============================================================================================
        # verificar área a ser pesquisada; não pode ser maior que 5000 km²
        crsSrc = QgsCoordinateReferenceSystem(QgsProject().instance().crs())
        crsDest = crsSrc
        proj2geo = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())
        extensao = proj2geo.transform(extensao)
        
        center_x = extensao.center().x()
        center_y = extensao.center().y()
        # Calcular o fuso UTM (cada fuso UTM tem 6 graus de largura)
        zone = int((center_x + 180) / 6) + 1
        # Determinar o EPSG p/o fuso UTM (usar 32700 p/o hemisfério sul e 32600 p/o hemisfério norte)
        if center_y < 0:
            crsProj = QgsCoordinateReferenceSystem(f"EPSG:{32700 + zone}")  # Hemisfério sul
        else:
            crsProj = QgsCoordinateReferenceSystem(f"EPSG:{32600 + zone}")  # Hemisfério norte

        transform = QgsCoordinateTransform(crsDest, crsProj, QgsProject.instance())
        extensao_proj = transform.transformBoundingBox(extensao)
        area = extensao_proj.area() / 1e6  # Dividir por 1.000.000 para converter para km²
        
        feedback.pushInfo(f"Área de {area} km²")
        
        if area > 5000:
            feedback.pushInfo("Área não pode ser maior que 5000 km²")
            feedback.pushInfo(f"Área da extensão: {area:.2f} km²")
            return {} # Parar o processamento retornando None
        
        # =============================================================================================
        # requisição ao GeoServer
        # construir o link
        geoserver_url = "http://167.88.39.28:8080/geoserver/Geoone/wfs" # "http://localhost:8080/geoserver/Geoone/wfs"
        geoserver_Camada = f"Geoone:{layer}"
        
        crs = 'EPSG:4674'
        
        minX = extensao.xMinimum()
        maxX = extensao.xMaximum()
        minY = extensao.yMinimum()
        maxY = extensao.yMaximum()

        wfs_url = (  # O GeoServer para fornecer ShapeFile precisa ser ZIP, pois há vários arquivos
            f"{geoserver_url}?service=WFS&version=1.0.0&request=GetFeature"
            f"&typeName={geoserver_Camada}&outputFormat=SHAPE-ZIP"
            f"&bbox={minX},{minY},{maxX},{maxY},{crs}"
        )
        
        response = requests.get(wfs_url, auth=('admin', 'Ge@nista2024')) # geoserver
        # fonte = """pagingEnabled='true' preferCoordinatesForWfsT11='false' restrictToRequestBBOX='1' srsname='EPSG:4674' typename='Geoone:Area_Maior_1800m' url='http://167.88.39.28:8080/geoserver/Geoone/wfs' version='auto'"""
        # camada = QgsVectorLayer(fonte,'Teste','WFS')

        if response.status_code == 200:
            project_dir = QgsProject.instance().homePath()  # Obtém o diretório do projeto
            car_folder = os.path.join(project_dir, 'CAR')   # Defina o caminho para a subpasta 'CAR'

            # Crie a pasta 'CAR' se ela não existir
            if not os.path.exists(car_folder):
                os.makedirs(car_folder)
            
            zip_file_path = os.path.join(car_folder, f"{layer}.zip")  # Nome do arquivo ZIP
            
            with open(zip_file_path, 'wb') as zip_file:
                zip_file.write(response.content)  # Salva o arquivo ZIP na pasta 'CAR'
            
            # Extraindo o conteúdo do arquivo ZIP
            with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
                zip_ref.extractall(car_folder)  # Extrai os arquivos na pasta 'CAR'
            
            feedback.pushInfo(f"Camada extraída com sucesso para: {car_folder}")
            
            # Adicionando a camada ao QGIS
            for file in os.listdir(car_folder):
                if file.endswith(".shp") and file[:-4] == layer:  # Verifica se é o arquivo shapefile
                    shapefile_path = os.path.join(car_folder, file)
                    layer_name = file[:-4]  # Remove a extensão .shp para nomear a camada
                    layer = QgsVectorLayer(shapefile_path, layer_name, "ogr")  # Cria a camada vetorial

                    if layer.isValid():
                        # Adiciona a camada na raiz do projeto e a coloca como a primeira camada
                        root = QgsProject.instance().layerTreeRoot()
                        QgsProject.instance().addMapLayer(layer, False)  # Adiciona a camada sem exibi-la imediatamente
                        root.insertLayer(0, layer)  # Insere a camada no topo da árvore de camadas
                        
                        feedback.pushInfo(f"Camada adicionada ao QGIS: {layer_name}")
                    else:
                        feedback.pushInfo(f"Erro ao carregar a camada: {layer_name}")
        else:
            feedback.pushInfo(f"Erro ao obter a camada do GeoServer: {response.status_code}")
            
        return {} 
        
    def name(self):
        return 'obtemCAR'.lower()

    def displayName(self):
        return self.tr('Camadas de Interesse')

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return obtemCAR()

    def icon(self):
        return QIcon(os.path.join(os.path.dirname(os.path.dirname(__file__)), 'images/geocar.png'))

    def shortHelpString(self):
        txt = 'Baixar camada CAR a partir de uma extensão (retângulo).'
        """footer = '''<div>
                      <div align="center">
                      <img style="width: 100%; height: auto;" src="data:image/jpg;base64,'''+ INCRA_GeoOne +'''
                      </div>
                      <div align="right">
                      <p align="right">
                      <a href="https://github.com/OpenGeoOne/GeoINCRA/wiki/Sobre-o-GeoINCRA#banco-de-dados-georural"><span style="font-weight: bold;">Clique aqui para conhecer o modelo GeoRural da GeoOne</span></a><br>
                      </p>
                      <a target="_blank" rel="noopener noreferrer" href="https://geoone.com.br/"><img title="GeoOne" src="data:image/png;base64,'''+ GeoOne +'''"></a>
                      <p><i>"Mapeamento automatizado, fácil e direto ao ponto é na GeoOne!"</i></p>
                      </div>
                    </div>'''
        return txt + footer
        """
        return txt

class Renamer (QgsProcessingLayerPostProcessorInterface):
    def __init__(self, layer_name):
        self.name = layer_name
        super().__init__()

    def postProcessLayer(self, layer, context, feedback):
        layer.setName(self.name)
